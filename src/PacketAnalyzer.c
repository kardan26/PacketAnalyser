/*
 ============================================================================
 Name        : PacketAnalyzer.c
 Author      : Daniel Karwowski
 Version     :
 Copyright   : maked by kardan
 Description : Hello World in C, Ansi-style
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>

#include <sys/socket.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>

#include "naglowki.h"
#include "funkcje.h"

int main(void) {
	//max eth = 6 + 6 +2 + 1500
	unsigned char bufor_eth_arp[1514] = {
										 0x30,0x85,0xa9,0x13,0x8e,0xaa,0x00,0x1a,0x92,0xb0,0x07,0x41,0x08,0x06,0x00,0x01,
										 0x08,0x00,0x06,0x04,0x00,0x02,0x00,0x1a,0x92,0xb0,0x07,0x41,0x0a,0x02,0x07,0x60,
										 0x30,0x85,0xa9,0x13,0x8e,0xaa,0x0a,0x02,0x07,0x79,0x00,0x00,0x00,0x00,0x00,0x00,
										 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	unsigned char bufor_eth_ip_icmp[1514]={
										0x00,0x09,0x0f,0xe7,0x86,0x23,0x30,0x85,0xa9,0x13,0x8e,0xaa,0x08,0x00,0x45,0x00,
										0x00,0x3c,0x65,0xb2,0x00,0x00,0xff,0x01,0x00,0x00,0x0a,0x02,0x07,0x79,0xac,0x14,
										0x32,0x32,0x08,0x00,0x2b,0x8a,0x3c,0x3c,0xdf,0x47,0x3c,0x3c,0xd7,0x47,0xfa,0xf0,
										0x2f,0xf7,0x09,0x72,0x86,0x48,0xb9,0xb4,0xe0,0xad,0x25,0x38,0xad,0x59,0x07,0x56,
										0xa7,0x0b,0x82,0x2f,0xbf,0x64,0x0a,0x9a,0x73,0x46

	};

	unsigned char bufor_eth_ip_udp[1514]={
										0x00,0x09,0x0f,0xe7,0x86,0x23,0x30,0x85,0xa9,0x13,0x8e,0xaa,0x08,0x00,0x45,0x00,
										0x00,0x3e,0x0c,0x0a,0x00,0x00,0x80,0x11,0x00,0x00,0x0a,0x02,0x07,0x79,0x0a,0x01,
										0x00,0x01,0xfe,0x08,0x00,0x35,0x00,0x2a,0x1b,0xb8,0x18,0x30,0x01,0x00,0x00,0x01,
										0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x77,0x77,0x77,0x08,0x6d,0x73,0x66,0x74,0x6e,
										0x63,0x73,0x69,0x03,0x63,0x6f,0x6d,0x00,0x00,0x01,0x00,0x01

	};

	unsigned char bufor_eth_ip_tcp[1514]={
										0x30,0x85,0xa9,0x13,0x8e,0xaa,0x00,0x09,0x0f,0xe7,0x86,0x23,0x08,0x00,0x45,0x00,
										0x00,0x6c,0x79,0xbf,0x40,0x00,0x31,0x06,0x34,0xea,0xd5,0xc7,0xb3,0xa0,0x0a,0x02,
										0x07,0x79,0x9c,0x4c,0xc5,0x4a,0x5a,0x01,0x51,0x73,0x38,0x5b,0x01,0xb2,0x50,0x18,
										0x00,0x1d,0xd8,0xe0,0x00,0x00,0xae,0xfb,0x85,0x90,0x37,0x8e,0xae,0xb5,0x03,0x4f,
										0xa6,0x2e,0x00,0x34,0xd8,0x4c,0x79,0x29,0x5e,0xa4,0x75,0x46,0xb9,0xa3,0x53,0x42,
										0xdb,0x11,0x77,0x71,0xc8,0xf9,0xab,0xb5,0x5e,0x84,0xe2,0x3e,0xb7,0x1c,0x4b,0x50,
										0x7f,0x6b,0x2c,0xa3,0xc1,0xaf,0x7d,0x50,0x65,0x66,0xa7,0xbd,0xb5,0x2e,0xb8,0x22,
										0x9f,0xd2,0x56,0x2c,0x7f,0xe8,0xcb,0xc9,0x4c,0x2d

	};

	//definicja zmiennych
	int s; /*deskryptor gniazda*/
	int j;
	int i = 0;
	int length = 0;

	//bufor dla ramek z Ethernetu
	void* buffer = (void*)malloc(ETH_FRAME_LEN);
	//wskaznik do naglowka Eth
	unsigned char* etherhead = buffer;
	//wskaznik do miejsca rozpoczecia danych
	unsigned char* data = buffer + 14;


	s = socket(AF_INET, SOCK_PACKET, htons(ETH_P_ALL));
	if (s == -1) {printf ("Nie moge otworzyc gniazda\n");}

	while (i<1) {
			//odbierz ramke Eth
			length = recvfrom(s, buffer, ETH_FRAME_LEN, 0, NULL, NULL);
			if (length == -1)
				printf ("Problem z odbiorem ramki \n");
			else {
				i++;
				printf ("Ramka: %d, dlugosc: %d [B]\n", i, length);
			}

			#if 1
			//wypisz zawartosc bufora
				for (j=0;j<length; j++) {
					printf ("%02x ", *(etherhead+j));
				}
				printf ("\n");
			#endif
	}

	ethernet2_frame et2;
	memcpy(&et2,etherhead,14);

	short type = et2.frame_type[0]<<8 | et2.frame_type[1];

	switch (type) {
		case 0x0800:
			printf("IPv4 \n");
			ip_frame ip4;
			memcpy(&ip4,etherhead+14,20);

			switch(ip4.protocol){
				case 0x06:
					printf("Ip Protocol Type : TCP\n");
					eth_ip_tcp_packet TCP;
					unsigned int tcp_size = sizeof(eth_ip_tcp_packet);
					convert_raw_to_tcp_packet(&TCP,&bufor_eth_ip_tcp,tcp_size);
					print_tcp(TCP);
					break;
				case 0x01:
					printf("Ip Protocol Type : ICMP\n");
					eth_ip_icmp_packet ICMP;
					unsigned int icmp_size = sizeof(eth_ip_icmp_packet);
					convert_raw_to_icmp_packet(&ICMP,&etherhead,icmp_size);
					print_icmp(ICMP);
					break;
				case 0x11:
					printf("Ip Protocol Type : UDP\n");
					eth_ip_udp_packet UDP;
					unsigned int udp_size = sizeof(eth_ip_udp_packet);
					convert_raw_to_udp_packet(&UDP,&bufor_eth_ip_udp,sizeof(bufor_eth_ip_udp));
					print_udp(UDP);
					break;
				default:
					printf("Ip Protocol Type : %02x\n",ip4.protocol);
			}
			break;
		case 0x0806:
			printf("ARP \n");
			eth_arp_packet ARP;
			unsigned int arp_size = sizeof(eth_arp_packet);
			convert_raw_to_arp_packet(&ARP,&etherhead,arp_size);
			print_arp(ARP);
			break;
		default:
			break;
	}


//	eth_arp_packet ARP;
//	unsigned int arp_size = sizeof(eth_arp_packet);
//	convert_raw_to_arp_packet(&ARP,&bufor_eth_arp,arp_size);
//	print_arp(ARP);
//
//
//
//
//	eth_ip_icmp_packet ICMP;
//	unsigned int icmp_size = sizeof(eth_ip_icmp_packet);
//	convert_raw_to_icmp_packet(&ICMP,&bufor_eth_ip_icmp,icmp_size);
//	print_icmp(ICMP);
//
//
//
//	eth_ip_udp_packet UDP;
//	unsigned int udp_size = sizeof(eth_ip_udp_packet);
//	convert_raw_to_udp_packet(&UDP,&bufor_eth_ip_udp,sizeof(bufor_eth_ip_udp));
//	print_udp(UDP);
//
//
//
//
//	eth_ip_tcp_packet TCP;
//	unsigned int tcp_size = sizeof(eth_ip_tcp_packet);
//	convert_raw_to_tcp_packet(&TCP,&bufor_eth_ip_tcp,tcp_size);
//	print_tcp(TCP);
//
//
//






	return EXIT_SUCCESS;
}
